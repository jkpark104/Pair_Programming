# Pair_Programming

## 1번 Toggle Side Nav

### 1. session storage가 아니라 local storage를 사용한 이유

- local storage는 의도적으로 지우지 않는 이상 영구적으로 저장이 가능합니다. 반면, session storage는 데이터가 지속적으로 보관되지 않아 세션이 종료되면 데이터도 같이 사라집니다.
- 문제의 요구사항에서는 reload, 페이지 이동시에도 적용된 상태를 유지해야한다는 조건이 있었기때문에 local storage를 사용하였습니다.

## 2번 Scrolling goto top

### 1. pageYOffset을 scrollY 대신 사용한 이유

- pageYOffset과 scrollY는 거의 동일하지만 pageYOffset이 지원 범위가 더 넓기때문에 pageYOffset을 사용하였습니다.

- pageYOffset은 문서가 수직으로 얼마나 스크롤됐는지 픽셀 단위로 반환합니다.

### 2. throttle을 사용한 이유

- 문제의 요구사항에서는 이벤트 핸들러가 과도하게 호출되지 않기를 바랬고, 이걸 구현하기 위해서는 쓰로틀을 사용해야합니다. 함수가 스크롤을 내릴때마다 계속 실행되는것을 방지하기위해서 100초마다 한 번씩만 스크롤이 발생하기위해서 사용했습니다.

## 3번 Counter

### 1. 클로저 활용

- 클로저를 활용하여 즉시실행함수로 묶어 정보 은닉화를 할 수 있었습니다.

- 증감 연산자는 증감시점이 헷갈린다는 단점이 존재하지만, counter에서는 일관적으로 증감연산자를 사용하고있고, 이를 사용했을때 가독성이 더 높아진다는 장점이 존재해 증감 연산자를 사용하기로 결정했습니다.

### 2. 이벤트 위임 사용하지 않은 이유

- 이벤트 위임을 사용하려고했지만, button뿐만 아니라 i 요소도 함께 눌러져 걸러줘야하는 경우의 수가 늘어났습니다. 이는 기존 코드보다 더 복잡해질 수 있기 때문에 그냥 기존처럼 DOM Nodes를 직접적으로 가지고와 활용했습니다.

### 3. 식별자 이름에 대한 고민

- 식별자 명에 대한 고민 : 처음에는 counter이라는 이름을 객체와 DOM Nodes에 두 번 사용했지만, 이는 중복으로 혼란을 야기할 수 있기때문에 다른 이름을 정하고자 했습니다. 토론끝에 DOM Nodes의 이름을 counterDisplay로 변경하고 객체를 counter로 남겨두기로 결정하였습니다. 그 이유는 counter이라는 객체는 increase, decrease 기능을 반환하는 역할이고 그것이 counter의 주요 기능과 일치한다고 생각해 counter이라는 이름이 적절하다고 판단했습니다. 반면, DOM Nodes의 경우는 이러한 기능을 보여주는 용도라고 판단했고 그래서 이름을 counterDisplay로 결정했습니다.

## 4번 Analog Clock

### 1. setTimeout 활용

- 1초마다 해당 함수를 실행하기 위해서 setTimeout을 사용했습니다.

### 2. 매직 넘버를 상수로 선언

- 매직 넘버는 어떤 역할을 하는지 모호하고 가독성을 떨어뜨리기 때문에 매직 넘버를 상수로 선언해 사용했습니다.

## 5번 StopWatch

### 1. setInterval 사용

- 주어진 시간이 끝날때마다 해당 함수가 계속 동작하도록 하기 위해서 setInterval을 사용했습니다.

### 2. 형식 규격화

- 한 자리 숫자인경우 length가 달라져 가독성을 해칠 수 있기 때문에 앞에 0을 넣어주며 형식을 맞추어 주었습니다.

### 3. 객체화

- StopWatch를 객체화시켜 스톱워치에 필요한 기능들을 객체의 프로퍼티로 넣어 구조화 시켜주고자 했습니다.

## 6번 Dark Mode

### 1. SetTimeout

- 리로드가 일어날때마다 깜빡임 문제를 해결하기위해 transition이 일어나는 시간 동안 화면을 잠시 보여주지 않도록 하기 위해 setTimeout을 사용했습니다.

### 2. `document.body.style.opacity`

- setTimeout 내부에 display와 opacity중 어떤 것을 사용할지 고민했습니다. `style.display = none` 은 300ms만큼 dom을 생성안하고 기다리다 300ms가 지난후에야 dom을 생성하게됩니다. 반면, `opacity = 0`은 dom은 바로 생성하지만 300ms동안 보여주지 않습니다. `display none`은 리플로우가 발생하기때문에 , opacity 0 을 사용하는것이 옳다고 판단하였습니다.

### 3. local storage

- 리로드가 발생해도 기존 설정을 기억하기 위해 local storage를 사용했습니다.

## 7번 Pop up

- 버튼이 눌러질 때마다 active 클래스를 추가/삭제되며 상황을 조절 해주고자 했습니다.

## 8번 Tabs

### promise 활용

- 데이터를 다 받아오기 이전에 화면에 스피너를 표시하기 위하여 promise를 사용하였습니다. 프로미스는 그리고 화면에 정보를 다 받아오면 스피너의 opacity 를 0으로 주었습니다. display none이 아닌 opacity를 0으로 준 이유는 리플로우를 발생시키지 않기 위해서입니다.

## 9번 Accordions

- target과 i가 같은 경우는 active를 클래스 리스트에 추가해주고 아닌경우는 active제거 해줌으로써 하나가 켜지면 자동적으로 하나가 꺼지도록 높이 조정을 해주게됩니다.

- 해당 메뉴가 active일때 높이값도 동적으로 관리해주도록 설정하였습니다.

## 10번 Toaster

- createToast 함수랑 add, remove기능을 담은 toaster 객체로 분리해주었습니다. 가장 먼저 toast를 만드는 것은 add, remove와는 결이 다른 문제라고 판단했습니다.

- 토스터가 추가될때마다 옆으로 늘어나며 가로스크롤이 생겨났습니다. 이 문제를 해결하기위해 overflow-x 를 hidden으로 하며 가로 스크롤이 생기는것을 막았습니다.

## 11번 Carousel Slider

### 1. 프로퍼티 함수 생성

- 캐러셀의 프로퍼티를 반복적으로 설정하다보니 프로퍼티 설정 함수를 만들어주었습니다. 여러개의 프로퍼티가 한꺼번에 설정될 수 있도록 forEach를 사용했습니다.

### 2. clientWidth vs scrollWidth vs offsetWidth

- 저희는 clientwidth를 사용했습니다. offsetWidth는 일반적인 엘리먼트의 사이즈를 보여주는것이라 목적에 맞지 않다고 판단해 배제를 했습니다. 처음에는 scroll width를 사용했지만, scroll width는 overflow 된 content까지 너비 계산에 포함해 저희가 원하는 사용자에게 보여지는 너비를 나타내지 않는다고 판단해 패딩과 너비를 포함한 cliendWidth를 사용해주었습니다.

### 3. transitionend

- 처음에 setTimeout을 사용해 transition을 조절 해주고자 하였지만, 결과는 저희가 원하는대로 나오지않았습니다. 그 이유는 delay 시간을 지정해주어도 정확하게 그 시간을 맞추는것을 보장해주는것이 아니라 그것보다 길어질 수 있다는 것입니다.

- 명확하게 delay시간 이후에 발생해야하는 경우이기때문에 setTimeout은 맞지 않다고 생각하였고, 캐러셀의 경우도 마찬가지로 이렇게 어긋나는 시간이 쌓이다보면 미묘하게 사진이 이상하게 보여질 가능성이 있어 transitionEnd를 사용하였습니다.

- transitionEnd는 사진이 움직이고 있을때는 클릭을 해도 무시하다가 transition이 끝이 나면 그때부터 클릭을 인식하도록 하는 방법입니다. 그래서 저희는 transitionEnd라는 변수를 사용해 불리언값 true를 주었고, false인동안에는 클릭을 무시했고, true로 변경되는 시점에는 클릭이 동작하도록 코드를 작성하였습니다.

### 5. 마지막, 첫번째 인덱스일 경우 처리 방법

- 사진에 트랜지션이 일어나면 안되는 마지막 구간인가 여부를 판단한 후 마지막 구간인 경우 `slideOrder = Math.abs(slideOrder - slideLastIndex + 1);`을 통해 이동해야할 사진의 인덱스번호를 구합니다. 그 인덱스 번호를 캐러셀 프로퍼티에 등록을해주며 계속 현상태를 관리할 수 있도록 했습니다.

- 아쉬운 점: 끝부분만이 아니라 전체의 다음 인덱스 번호를 구하는 함수를 만들 지 못했다는 점과 transitionEnd가 다른 값보다 먼저 위치해있다는 점이 아쉬웠습니다.

## 12번 Calendar & Date picker

### 1. month, date 이름 영문으로 출력하기

- 처음에는 months라는 배열을 만들어 사용했지만, 불필요한 배열 남발이라고 판단을해 `new Date(0, month).toLocaleString('en-us', { month: 'long' }` 방법을 사용해여 필요한 각각의 달의 이름을 뽑아내 사용하였습니다.

- conertDateFormat은 각 연월일을 우리가 원하는 달력 형식의 날짜로 바꾸어 주는 함수 기능을 구현하였습니다. 그리고 만약 날짜가 10보다 작은 숫자라면 가독성을 위해 앞에 0을 붙여 길이를 맞추어주고자 했습니다.

- getDate함수를 만들어 현재, 지난달, 다음 달의 날짜를 구하도록 계산했습니다. 이렇게 하나의 함수로 묶어주며 가독성과 함께 복잡했던 코드를 깔끔하게 구현할 수 있었습니다.

- sunday, today, selected로 세가지 날짜에 따로 state를 주며 css를 조절해주었습니다.

## 13번 Form validation

### 1. Debounce를 사용

- 스로틀은 두 번째 인자에 시간이 주어지면 그 시간동안 이벤트가 발생해도 무시하고 시간이 지난 후에야 콜백함수가 실행이 됩니다. 반면, 디바운스는 어떤 이벤트가 더 이상 발생하지않을때 두 번째 인자에 주어진 시간이 지난 후에야 콜백함수가 실행이됩니다. 그래서 자동입력필드는 계속 입력이 들어오다 멈춤이 발생했을때 체크가 필요하므로 debounce를 사용해 성능을 개선시키고자 했습니다.
